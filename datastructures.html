<!DOCTYPE html>
<html>
<head>
	<title>Data Structures</title>
<style>
* {
  box-sizing: border-box;
}

body {
  font-family: Arial, Helvetica, sans-serif;
}

/* Float four columns side by side */
.column {
  float: left;
  padding: 0 10px;
}

/* Remove extra left and right margins, due to padding in columns */
.row {margin: 20px 5px;}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

/* Style the counter cards */
.card {
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2); /* this adds the "card" effect */
  padding: 12px;
  background-color: #f1f1f1;
}

/* Responsive columns - one column layout (vertical) on small screens */
@media screen and (max-width: 600px) {
  .column {
    width: 100%;
    display: block;
    margin-bottom: 20px;
  }
}
}
</style>
</head>

<body>
	<div id = "header">
	</div>

	<h1>Data Structures</h1>
	<p> This page contains a reference sheet of all data structures and important characteristics. It stretches from primitive structures to more advanced and nuanced uses. We also attempted to put the pros and cons and basic use cases for each structure. </p>


<!-- Array Data Structure !-->
  <div class="row">
    <div class="card">
      <h2> Array </h2>
      <p> The Array is one of the simplest data structures. At time of declaration, the space required to store the array is reserved. Each entry can be accessed and modified in constant time. However, arrays have set size, so an insertion can overflow the array and require resizing, an expensive operation.
      </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Access </h3>
          <p> O(1) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Search </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 50%">
        <div class = "card">
          <h3> Insert / Deletion </h3>
          <p> O(1) (if array not full) </p>
          <p> O(n) (if full) </p>
          <p> <small> *Note O(n) cost can be amoritized to O(1) if array size is doubled upon insertion </small> </p>
        </div>
      </div>

    </div>
  </div>

<!-- Linked List Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Linked List </h2>
      <p> The linked list is an array-type data structure that enables inserting in constant time. In is accomplished by creating "nodes" with which each contains the stored value and a reference to the next node in the list. However, the data may be stored in separate parts of memory, meaning that you must step through the array for search.
      </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Access </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Search </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Insert / Deletion </h3>
          <p> O(1) </p>
        </div>
      </div>

    </div>
  </div>
	
<!-- Stack Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Stack </h2>
      <p> A stack is a data struture with specific functionality - top(), push(), and pop(), to access the first element, push something on the stack, and remove the top element of the stack. Stacks are LIFO (last-in first-out). Important component for different algorithms. A stack can be implemented via a ListStack (where it is easy to pop and add at the head node), or ArrayStack, where is faster but may require regrowing since arrays are static-size.
      </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Access </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Search </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Insert / Deletion </h3>
          <p> O(1) </p>
        </div>
      </div>

    </div>
  </div>


<!-- Queue Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Queue </h2>
      <p> Queue is very similar to a real-life queue; a line for an event. Has FIFO ordering (first-in first-out), and supports operation empty(), front(), dequeue(), and enqueue(). Elements can only be inserted into the back of the structure and removed from the front. Implemented with ListQueue or ArrayQueue.
      </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Access </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Search </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Insert / Deletion </h3>
          <p> O(1) </p>
        </div>
      </div>

    </div>
  </div>

  <!-- Dequeue Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Deque </h2>
      <p> Short for double-ended queue, this data structure is the same as a queue, but now enables insertFront(), insertBack(), removeFront(), removeBack(). Can be implemented via ListQueue or ArrayQueue, but a ListQueue would require a doubly-linked list underlying structure.
      </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Access </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Search </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Insert / Deletion </h3>
          <p> O(1) </p>
        </div>
      </div>

    </div>
  </div>


<!-- Tree Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Tree </h2>
      <p> A tree is a node-based data structure where each node both contains data and n-pointers to children. When n=2, the tree is said to be a binary-tree. They are often used for sorting numbers, where the left of every node has values smaller than the node, and the right has larger values.
      </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Access </h3>
          <p> O(log n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Search </h3>
          <p> O(log n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Insert / Deletion </h3>
          <p> O(log n) </p>
        </div>
      </div>

    </div>
  </div>


<!-- Graph Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Graph </h2>
      <p> A graph can be though of as a "lose" tree. Graphs are defined as a collection of nodes, each with a value and a set of pointers to nodes it is connected to. Often implmeneted with an array of nodes, with each node holding the data and in + out edges.
      </p>
    </div>
  </div>

  <!-- Heap Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Heap </h2>
      <p> A heap is a tree with two properties enforced. 1. Shape: It is a complete binary tree (except bottom row). 2. Ordering: Each node is greater than its children. Can be implimented via nodes or in an array, with parent(i) being index i/2, and left-child(i) = 2i, right-child(i) = 2i + 1. Heap is a great data structure for sorting, where you can pop off the top in O(1), readjust the heap in O(log n) and thus sorting is O(n log n). 
      </p>
      <p> Inserting: Put the element in the final position and swap "up" the tree until its parent is larger than it </p>
      <p> Removing: Swap the top and the last element. Remove the last and swap the top down each larger child </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Insert </h3>
          <p> O(log n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Remove </h3>
          <p> O(log n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 50%">
        <div class = "card">
          <h3> Heapify </h3>
          <p> O(n) </p>
          <p> <small> Can be done bottom up. Bottom row (2^r) elements move 1 spot, 2^(r-1) move 2, etc which converges to n </small> </p>
        </div>
      </div>

    </div>
  </div>

  <!-- Priority Queue Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Priority Queue </h2>
      <p> A priority queue is a queue with limited functionality: insert(), top(), and remove() set to be as fast as possible. It is typically implemented with a heap underlying, and come in maxPQ or minPQ variety (for min, heap ordering property is reversed). Data is inserted into the heap and ordered, removed in O(1), and readjusted in O(log n).
      </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Insert </h3>
          <p> O(log n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Top </h3>
          <p> O(1) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Remove </h3>
          <p> O(log n) </p>
        </div>
      </div>

    </div>
  </div>

  <!-- Set Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Set </h2>
      <p> A set is a specialized data structure that deals with the presence or absence of an element. They support functionality: insert(), remove(), and a boolean has(). Sets can be implimented with either an array, linked list, or tree. Sets can be versatile depending on use cases. </p>
      <p> Fast Insertion: Just add the element to the end of the array. Since data is not ordered search will be O(n) </p>
      <p> Fast Find (Ordered Set): If data is ordered, insert at the correction ordering position after binary search. However, will require shifting data in the array. Search is O(log n)  </p>
      <p> Speed can be marginally optimized by simple heuristics (if not using Ordered Set). Move-to-front: upon finding x, swap it with the front element for faster search. Transpose: If found, swap it one spot forward. </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Insert </h3>
          <p> O(1) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Remove </h3>
          <p> O(n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Has </h3>
          <p> O(n) </p>
        </div>
      </div>

    </div>
  </div>


  <!-- Integer Set Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Integer Set </h2>
      <p> A form of set that can be really fast for discrete input with a defined range. Create an array of all 0s having the size of the range. If the i-th value occurs, increment the i-th entry in the array. Used in bucket sort. </p>
      <p> A bit set is the same idea, only the data is stored in the i-th bit (1 and 0 for presence and absence). Saves space by ~8x. </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Insert / Remove </h3>
          <p> O(1) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Has </h3>
          <p> O(1) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Space </h3>
          <p> O(range) </p>
        </div>
      </div>

    </div>
  </div>


  <!-- Map Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Map </h2>
      <p> A map is a dictionary from a key to a value. used to determine if a node is in a graph or to get a name from an ID. Has functionality insert(K, V), remove(K), get(K). Primitive options area parallel arrays or a linked list of key / value nodes. Hash maps, AVL trees, and treaps are two implementations of a map.</p>

    </div>
  </div>

  <!-- Hash Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Hash Table (Hash Map) </h2>
      <p> A hash map is one of the most widely-used data structures. It is a map from keys to values, where the key is "hashed" (put through a function to get a ranged integer) and then stored at that position in an array. This allows for O(1) insertion, deletion, and reading. However, hashing does not fair well for printing ordered data as the hash function can be though of as "random".  </p>
      <h4> Collisions </h4>
      <p> Issues arise when two keys are hashed to the same position (bucket). These are callsed "collisions" and are dealt in different ways </p>
      <p> Separate Chaining: Put a linked list at the bucket and iterate through </p>
      <p> Linear Probing: Just store the collision value directly after its hashed spot. If there is a collision there, repeat with the next spot until there is an opening. On search, you would searech until encountering an empty spot. Suffers from clustering. </p>
      <p> Quadratic Probing: Using the same strategy as Linear Probing, though to avoid clustering, looks 1, 4, 9, ... etc steps forward. Hash table should have a prime size to sample all possible spaces </p>
      <p> Double Hashing: On collesions, a second hash value determines the step. </p>
      <p> Cookoo Hashing: Hash into one table. If there is a collision, hash into a second table using a second hash function. If there is a collision there, continue to hash back to the first table and repeat. If there takes longer than a specified side, then resuffle the data. </p>
      <p> Bloom Filter: Use bits and hash a value into a collection of bits. In an array of bits, compute the or of the hashed value and the array of bits. If all bits in a search are true, the key is likely in the set </p> 

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Insert / Remove </h3>
          <p> O(1) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Has </h3>
          <p> O(1) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Space </h3>
          <p> O(n) </p>
        </div>
      </div>

    </div>
  </div>


  <!-- AVL Tree Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> AVL Tree </h2>
      <p> An AVL tree is a map and a binary search tree combined. It has the property that at any point in time, the left size and the right size of each node has hights that differ by less than 2. Through a series of rotations, the tree keeps balanced. Since the tree is balanced (depth is O(log n)). The keys are then searched according to a binary search tree, where for any node, the left and the right children are smaller and larger respectively. Rotations are difficult to implement but avoid worst-case O(n) find. </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Insert / Remove </h3>
          <p> O(log n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Has </h3>
          <p> O(log n) </p>
        </div>
      </div>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Height </h3>
          <p> O(log n) </p>
        </div>
      </div>

    </div>
  </div>


  <!-- Treaps Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Treaps </h2>
      <p> Treaps are a randomized form of a binary search tree. Each node has a user-defined key, and a random priority. The treap contains elements of a BST and a heap, where like a heap, higher priorities are closer to the root node than lower priorities, and keys follow the rule that left children are lesser and right children are larger of each node. Treaps avoid rotations and have expected good runtime. However, is still possible (but unlikely) to have worst case O(n) search. </p>

      <div class = "column" style= "width: 50%">
        <div class = "card">
          <h3> Insert / Remove </h3>
          <p> Expected: O(log n) </p>
          <p> Worst case: O(n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 50%">
        <div class = "card">
          <h3> Has </h3>
          <p> Expected: O(log n) </p>
          <p> Worst case: O(n) </p>
        </div>
      </div>

    </div>
  </div>


  <!-- Suffix Array Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Suffix Array </h2>
      <p> It is hard to determine if a string concerns a substring. Solution: store an int that is the part of the string from the int position to the end. Then, we can sort on those int positions. Note though, this sorting step is slow. After then, any new string can be binary searched and the index returned.  </p>

    </div>
  </div>

    <!-- Disjoint Set Data Structure !-->

  <div class="row">
    <div class="card">
      <h2> Disjoint Set (Union Find) </h2>
      <p> A union find is a powerful data structure to determine of which group a value is in (from a collection of unions). It is made via two parallel arrays. One is the values, one is the group it is in. When a union occurs (a union b), the group of a is set to the group of b, and then each sub-group of a is set to the group of b as well (path conpression). This results in an extremely fast way to determine if two elements are in the same subset. </p>

      <div class = "column" style= "width: 25%">
        <div class = "card">
          <h3> Union </h3>
          <p> O(log* n) </p>
        </div>
      </div>

      <div class = "column" style = "width: 25%">
        <div class = "card">
          <h3> Find </h3>
          <p> O(log* n) </p>
        </div>
      </div>

    </div>
  </div>


    </div>
  </div>
</body>
</html>